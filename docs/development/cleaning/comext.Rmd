---
title: "Using tradeflows function on the Comext data"
author: "Paul Rougieux"
date: "04/12/2014"
output: html_document
---


```{r packages, echo=FALSE, warning=FALSE, message=FALSE}
library(knitr)
opts_knit$set(root.dir="../../..") # file paths are relative to the root of the project directory
opts_chunk$set(echo=FALSE)
library(tradeflows)
library(dplyr)
library(tidyr)
library(ggplot2)
``` 

```{r databasetableanalysed, echo=FALSE}
# Comment out to pass tableanalysed as a parameter in the parent environment
recenttable <- 'raw_comext_monthly_201709' 
archivetable <- 'raw_comext_monthly_2016S1'
# Use a product which doesn't have a zero quantity
# Tropical product (data starts only in 2012)
# productanalysed <- 44072960 
# Spruce sawnwood sub-product with the most number of lines (data starts as early as  2000)
productanalysed <- 44071091
# Another spruce
# productanalysed <- 44071031
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "tradeflows")
```

This document first tries to run the existing clean function 
- written for Comtrade data - on Comext data.
Then it describes the development process needed to make
the clean function work with Comext data.


# Run the existing `tradeharvester::transfer7zfolder2db()` function on the Comext data

Note: 0 zero values and empty strings were replaced by NA (NULL in Mysql)
during the load operation performed by `


```{r load_data_and_descriptive_statistics, echo=TRUE}
wp <- tbl(con, recenttable) %>% 
    filter(productcode == 44071031) %>% 
    collect()
# Descriptive statistics
# number of rows
wp %>% count()
# Summary of data columns for that product
summary(wp[c("tradevalue", "weight","quantity")])
# Number of 0 values
wp %>% filter(tradevalue == 0) %>% count()
wp %>% filter(weight== 0) %>% count()
wp %>% filter(quantity == 0) %>% count()
```

## Crash test run the clean() function alone
```{r eval=FALSE}
clean(wp)
```


## Run components of the clean() function one by one


```{r eval=FALSE}
# sanitycheck OK
wp %>% 
    sanitycheck() 

# filterworldeu28 OK
wp %>% 
    # add dummy reporter and partner columns 
    # mutate(reporter = NA,
    #        partner = NA) %>%  
    # Dummy reporter & partner are not necessary since 20170911, 
    # the filterworldeu28() function now checks for the presence
    # of a "reporter" column and gives a warning if not present.
    filterworldeu28()

# removeduplicatedflows
wp %>% 
    mutate(lastchanged = NA,
           flow = flowcode,
           reporter = reportercode) %>% # add dummy columns
    removeduplicatedflows()
    
# addconversionfactorandprice --> price/weight is missing, 
# add pricew = tradevalue / weight to the function
wp %>% 
    addconversionfactorandprice()

# addregion --> leads to erroneous region names since reportercde and partnercode a
# are different between the Comtrade and Comext.
wp %>% 
    addregion()

# extractprices
price <- wp %>% 
    mutate(flow = flowcode, 
           regionreporter = 1, 
           year = substr(as.character(period),1,4),
           unit = NA) %>% 
    addconversionfactorandprice() %>% 
    extractprices()

# extractconversionfactors
conversionfactor <- extractconversionfactors(dtf, geoaggregation = geoaggregation)
```


# Develop a new clean function for Comext data


## Reflections
The goal is to reuse as many components from the Comtrade function 
as possible. When it is not possible to reuse and or modify a function 
written for Comtrade, then write a new function, which should still be 
present in the tradeflows package, but in a separate script called
`cleancomext.R`. These - Comext specific - functions 
might be moved later to the "eutradeflows" package if they become too numerous.
However, there is no need to complexify the package structure.
If there is only a handfull of - Comext speficic - functions, then they are well placed in tradeflows package.

There is a difference between:

* extracting median prices (and price bounds)
  from monthly prices grouped by product, flow and year
* and extraction median prices (and price bounds)
  from yearly prices grouped by product, flow and year.

Trade flows data cleaning steps:

 * Add prices and conversion factors
 * Shave prices

### Reflections on prices and conversion factors
I think prices and conversion factors can be storred in the same database
table since they will beused at the same aggregation level. 
I first added `` to the extractprices() function. 
Then realised there were Inf et NaN values in the conversion factor. 
Which were normally filtered in 
This means I will keep the 2 functions separate. 
I'll keep the 2 tables separate in the database too. 
Since I can't think of an absolute necessary to keep them together.
And there is a slight chance that I might need different aggregation level
for the 2 informations in the future.


## Extract prices and write them to the database

```{r}
# wp stands for wood products
wparchive <- tbl(con, archivetable) %>% 
    filter(productcode == productanalysed) %>% 
    collect()
wprecent <- tbl(con, recenttable) %>% 
    filter(productcode == productanalysed) %>% 
    collect()
# Reassamble recent and archive data in one data frame    
wp <-  rbind(wparchive, wprecent)

# Extract year with integer division
wp$year <- wp$period %/% 100
years <- unique(wp$year)
# Are there any missing years?
identical(min(years):max(years), as.integer(years))

wp <- wp  %>% 
    addconversionfactorandprice() 

prices <- wp %>%
    # grouping by productcode is technicaly not necessary, because
    # cleaning operations are performed product by product.
    # But it doesn't cost much to keep the product information in the grouping,
    # and it might prevent confusion in later data processing,
    # so keep "productcode" in the grouping.
    extractprices(grouping = c("productcode", "flowcode", "year")) %>% 
    # rename year to period
    rename(period = year)


# What DB is currently connected?
message("Connected to the `", RMySQL::dbGetInfo(con)$dbname, "` database.")

# Write prices to the database
RMySQL::dbWriteTable(con, "vld_comext_price", prices,
                     append = TRUE,
                     row.names = FALSE)

```


```{r plotprices}
prices %>% 
    gather(key, value, -productcode, -flowcode, - year) %>% 
    # Add flow names for the plot
    left_join(data_frame(flowcode = c(1,2), flow = c("Import", "Export")),
              by = "flowcode") %>%
    ggplot(aes(x = year, y = value, color = key)) + 
    geom_line() +
    facet_wrap(~flow)
```

## Extract pricew and write them to the database

```{r}
pricew <- wp %>% 
    extractpricew(grouping = c("productcode", "flowcode", "year")) %>% 
    rename(period = year)
RMySQL::dbWriteTable(con, "vld_comext_pricew", pricew,
                     append = TRUE,
                     row.names = FALSE)
```


## Extract conversion factors and write them to the database
```{r}
# current calculation has potentially 12 flows between 2 partner in each
# flow direction for each product per year. 
# I could also perform instead a year grouping before the calculation
# so that there would only be one flow per year.
# And then use the year variable in the grouping. 
cv <- wp %>% 
    extractconversionfactors(grouping = c("productcode", "flowcode", "year")) %>% 
    rename(period = year)
# Before using append=TRUE, you should empty the table
RMySQL::dbSendQuery(con, "TRUNCATE table vld_comext_cv")
RMySQL::dbWriteTable(con, "vld_comext_cv", cv,
                     append = TRUE,
                     row.names = FALSE)

```



```{r dbDisconnect}
RMySQL::dbDisconnect(con)
```

