---
title: "Extract unique product codes from the Comext Combined Nomenclature codes"
output:
  html_document:
    toc: true
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}
library(knitr)
opts_knit$set(root.dir="../../..") # file paths are relative to the root of the project directory
library(tradeflows)
library(dplyr)
library(reshape2)
library(tidyr)
``` 


# If codes are not present, transfer them
```{r eval=FALSE}
if(FALSE){ # If codes are not present, transfer them
    # create emtpty database structure for raw codes
    createdbstructure(sqlfile = 'raw_comext.sql', dbname = 'test')
    # create empty database structure for validated codes
    createdbstructure(sqlfile = 'val_comext.sql', dbname = 'test')
    # transfer raw codes
    con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
    tradeharvester::transfertxtcodesfolder2db(con, rawdatacomextfolder = "~/R/tradeharvester/data-raw/comext/201707/text/english/")
    RMySQL::dbDisconnect(con)
}
```


# Explore raw product codes 
## Load raw product codes in a data frame
```{r loadproductsfromdb}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")

# Load all products in a dataframe
allproducts <- tbl(con, "raw_comext_product") %>% collect()
RMySQL::dbDisconnect(con)

# Keep wood products only
wp <- allproducts %>% 
    filter(grepl("^44|^94", productcode))

# For information regexp filtering is also possible with a SQL statement, 
# see for example 
# https://stackoverflow.com/questions/15687136/logical-and-operator-in-mysql-regexp
# and MySQL regexp documentation
# https://dev.mysql.com/doc/refman/5.5/en/regexp.html

# Why are dates read as character vectors?

```

## Are recent product codes unique?
```{r search4uniquecodes}
# A data frame to view in the data explorer
wpdates <- wp %>% 
    group_by(productcode) %>% 
    summarise(maxdatestart = max(datestart),
              datestart = paste(datestart, collapse=", "), 
              dateend = paste(dateend, collapse = ", "),
              # keep only distinct product description
              productdescription = paste(unique(productdescription), collapse = ", "),
              n = n()) %>% 
    arrange(desc(n))

# Wood products repeated
# Keep only the most recent datestart, which still appears more than once
wprep <- wp %>% 
    group_by(productcode) %>% 
    filter(datestart == max(datestart)) %>% 
    summarise(datestart = paste(datestart, collapse=", "), 
              dateend = paste(dateend, collapse = ", "),
              # keep only distinct product description
              productdescription = paste(unique(productdescription), collapse = ", "),
              n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>1) 
wprep %>% kable()

# It seems these lines contain identical information
# In other words, distinct rows for all columns
nrow(unique(wprep)) 
# should be equal to distinct product codes
length(unique(wprep$productcode))
# This can be tested with 
stopifnot(identical(nrow(unique(wprep)), length(unique(wprep$productcode))))    
```

 
## Are datestart2 and dateend2 allways identicall to datestart and dateend?
```{r}
summary(allproducts$datestart == allproducts$datestart2)
summary(allproducts$dateend == allproducts$dateend2)
diffdates <- allproducts %>% 
    filter(datestart != datestart2 |
           dateend != dateend2)
```
No there are 8 rows in which this is not the case.

# cleancodes
## 20170816 cleancodes function debugging before the change of productcodes to a character variable
```{r eval=FALSE}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
inputfields <- RMySQL::dbListFields(con,"raw_comext_product")
outputfields <- RMySQL::dbListFields(con,"val_comext_product")
# validated fields should exist in the raw table
stopifnot(outputfields %in% inputfields)

# clean products:
cleancode(con, "raw_comext_product", "val_comext_product", productcode)
# inside that function, dtf has 21833 rows, this is the number of most recent codes
# returns the error
# Error: identical(nrow(unique(dtf)), nrow(distinct(dtf, !(!codevariable)))) is not TRUE

# Load all products in a dataframe
allproducts <- tbl(con, "raw_comext_product") %>% collect()
RMySQL::dbDisconnect(con)


# Select output fields
# allproducts %>% select(outputfields)
# allproducts[outputfields]

dtf <- allproducts %>% 
    group_by(productcode) %>%
    filter(datestart == max(datestart))
stopifnot(identical(nrow(unique(dtf)),
                    nrow(distinct(dtf, productcode))))
# difference
nrow(unique(dtf)) - nrow(distinct(dtf, productcode))

# What are those duplicated rows?
# group by productcode
dtf_c <- dtf %>%  
    group_by(productcode) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_c_u <- unique(dtf_c)
length(unique(dtf_c_u$productcode))

# group by productcode and productdescription
dtf_cd <- dtf %>%  
    group_by(productcode, productdescription) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_cd_u <- unique(dtf_cd)
length(unique(dtf_cd_u$productcode))

# group by productcode, productdescription, datestart and dateend
dtf_cdse <- dtf %>%  
    group_by(productcode, productdescription, datestart, dateend) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_cdse_u <- unique(dtf_cdse)
length(unique(dtf_cdse_u$productcode))


# It seems the descriptions are different:
dtf_c_u$productdescription[1:5]
```


### Reading the raw text file directly
```{r}
# Looking at the source file, the duplicated codes issue seems to be due to the fact that 
# productcodes do not contain only numbers, but can also contain characters
# Reading the text file line by line
readLines("../tradeharvester/data-raw/comext/201707/text/english/CN.txt") %>% 
    grep("7302;", ., value=TRUE)
# For example 7302I0 or 7302I2 are product codes, which get truncated during the database load process.

# I decided to change this variable to a VARCHAR type in MySQL

# Trying to read the text file into a data frame
# Maximum character length
# product <- read.table("../tradeharvester/data-raw/comext/201707/text/english/CN.txt",
#                       sep = "\t")  
# Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec,  : 
#   line 5534 did not have 6 elements
cntxt <- readLines("../tradeharvester/data-raw/comext/201707/text/english/CN.txt")
cntxt[5534]
# but it does have 6 elements!
product_20089218 <- read.table(text = cntxt[5534], header = FALSE, sep="\t")
# cntxt[c(1:5533,5535,length(cntxt))]
product0 <- read.table(text = paste(cntxt[1:1000],collapse="\n"), 
                  header = FALSE, sep = "\t")
max(nchar(as.character(product0$V1)))

# I'll make it a varchar(10)
```


## cleanallcodes function
```{r}
# See steps above to recreate the database if needed
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")


try(cleancode(con, "raw_comext_product", "val_comext_product", productcode))



# In debug mode inside the cleancode function,
# nrow(dtf) 
# [1] 23994
# nrow(unique(dtf))
# [1] 23994
# Browse[2]> nrow(distinct(dtf, !!codevariable))
# [1] 23994
# Are there no duplicates?

# number of rows
res <- RMySQL::dbSendQuery(con, "SELECT COUNT(*) as nrow FROM val_comext_product")
sqltable <- RMySQL::dbFetch(res)
RMySQL::dbClearResult(res)
sqltable$nrow

RMySQL::dbDisconnect(con)

```


# Add information 
## Merge with dplyr::left_join
```{r}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
# tables
product <- tbl(con, "val_comext_product")
reporter <- tbl(con, "val_comext_reporter")
partner <- tbl(con, "val_comext_partner")
monthly <- tbl(con, "raw_comext_monthly_201707")


# if needed put back the data again
if(FALSE){
    # Run this in a separate R session, the transfer will take several minutes
    library(tradeharvester)
    setwd("~/R/tradeharvester")
    con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
    transfer7zfolder2db(con,
                        rawdatacomextfolder = "data-raw/comext/201707/data",
                        productcodestart = c(44, 94),
                        tablename = "raw_comext_monthly_201707",
                        tabletemplate = "raw_comext_monthly")
    RMySQL::dbDisconnect(con)
}


# Get only raw data for one product code
wp <- monthly %>% 
    filter(productcode == 44L) %>% collect()
# Get raw data with product and country information for one product code
query <- monthly %>% 
    filter(productcode == 44L) %>% 
    # join    
    left_join(product, by = "productcode") %>% 
    left_join(reporter, by = "reportercode") %>% 
    left_join(partner, by = "partnercode")
# Show the SQL query
query %>% explain()
# Get data from the database
dtf <- query %>% collect()
dtf %>% head %>% kable()

RMySQL::dbDisconnect(con)

```


### Use the function addproreppar2tbl
```{r}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
monthly <- tbl(con, "raw_comext_monthly_201707")
m44 <-monthly %>%
    filter(productcode == 44) %>%
    addproreppar2tbl(con, .) %>%
    collect()
m44 %>% head(20) %>%  kable()
unique(m44[c("productcode","productdescription")])
```


## Merge with SQL LEFT JOIN 
```{sql sqlfromdplyr, connection=con}
SELECT *
  FROM (SELECT `TBL_LEFT`.`reportercode` AS `reportercode`, `TBL_LEFT`.`partnercode` AS `partnercode`, `TBL_LEFT`.`productcode` AS `productcode`, `TBL_LEFT`.`flowcode` AS `flowcode`, `TBL_LEFT`.`statregime` AS `statregime`, `TBL_LEFT`.`period` AS `period`, `TBL_LEFT`.`tradevalue` AS `tradevalue`, `TBL_LEFT`.`weight` AS `weight`, `TBL_LEFT`.`quantity` AS `quantity`, `TBL_LEFT`.`productdescription` AS `productdescription`, `TBL_RIGHT`.`reporter` AS `reporter`
  FROM (SELECT `TBL_LEFT`.`reportercode` AS `reportercode`, `TBL_LEFT`.`partnercode` AS `partnercode`, `TBL_LEFT`.`productcode` AS `productcode`, `TBL_LEFT`.`flowcode` AS `flowcode`, `TBL_LEFT`.`statregime` AS `statregime`, `TBL_LEFT`.`period` AS `period`, `TBL_LEFT`.`tradevalue` AS `tradevalue`, `TBL_LEFT`.`weight` AS `weight`, `TBL_LEFT`.`quantity` AS `quantity`, `TBL_RIGHT`.`productdescription` AS `productdescription`
  FROM (SELECT * FROM `raw_comext_monthly_201707` WHERE (`productcode` = 44)) `TBL_LEFT`
  LEFT JOIN `val_comext_product` AS `TBL_RIGHT`
       ON (`TBL_LEFT`.`productcode` = `TBL_RIGHT`.`productcode`)) `TBL_LEFT`
  LEFT JOIN `val_comext_reporter` AS `TBL_RIGHT`  
       ON (`TBL_LEFT`.`reportercode` = `TBL_RIGHT`.`reportercode`)) `TBL_LEFT`
  LEFT JOIN `val_comext_partner` AS `TBL_RIGHT`
       ON (`TBL_LEFT`.`partnercode` = `TBL_RIGHT`.`partnercode`)
```
Is it possible to reduce the size of this chunk?

Stackoverflow [Multiple left join and where clause](https://stackoverflow.com/a/14261094/2641825)

```{sql eval=FALSE}
SELECT something
FROM   master      parent
JOIN   master      child ON child.parent_id = parent.id
LEFT   JOIN second parentdata ON parentdata.id = parent.secondary_id
LEFT   JOIN second childdata ON childdata.id = child.secondary_id
WHERE  parent.parent_id = 'rootID'
```
    
    
## Join 2 tables
```{sql eval=FALSE}
SELECT *
FROM   raw_comext_monthly_201707
JOIN   val_comext_product ON  raw_comext_monthly_201707.productcode = val_comext_product.productcode
WHERE  raw_comext_monthly_201707.productcode = 44
```


### Join 4 tables: monthly data, product, reporter, partner 
```{sql eval=FALSE}
SELECT *
FROM   raw_comext_monthly_201707
LEFT JOIN val_comext_product ON  raw_comext_monthly_201707.productcode = val_comext_product.productcode
LEFT JOIN val_comext_reporter ON raw_comext_monthly_201707.reportercode = val_comext_reporter.reportercode
LEFT JOIN val_comext_partner ON raw_comext_monthly_201707.partnercode = val_comext_partner.partnercode
WHERE  raw_comext_monthly_201707.productcode = 44
```


The same using an alias
```{sql sqlwithalias, connection=con}
SELECT *
FROM   raw_comext_monthly_201707 as m
LEFT JOIN val_comext_product ON m.productcode = val_comext_product.productcode
LEFT JOIN val_comext_reporter ON m.reportercode = val_comext_reporter.reportercode
LEFT JOIN val_comext_partner ON m.partnercode = val_comext_partner.partnercode
WHERE  m.productcode = 44
```


# Conclusions
cleancodes should first create the database structure.
The cleancode function should check which columns are present in the validated
table and select only these ones. 

