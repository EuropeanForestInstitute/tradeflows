---
title: "Extract unique product codes from the Comext Combined Nomenclature codes"
output:
  html_document:
    toc: true
---

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}
library(knitr)
opts_knit$set(root.dir="../../..") # file paths are relative to the root of the project directory
library(tradeflows)
library(dplyr)
library(reshape2)
library(tidyr)
``` 


# If codes are not present, transfer them
```{r eval=FALSE}
if(FALSE){ # If codes are not present, transfer them
    # create emtpty database structure for raw codes
    createdbstructure(sqlfile = 'raw_comext.sql', dbname = 'test')
    # create empty database structure for validated codes
    createdbstructure(sqlfile = 'val_comext.sql', dbname = 'test')
    # transfer raw codes
    tradeharvester::transfertxtcodesfolder2db(con, rawdatacomextfolder = "~/R/tradeharvester/data-raw/comext/201707/text/english/")
}
```


# Explore raw product codes 
## Load raw product codes in a data frame
```{r loadproductsfromdb}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")

# Load all products in a dataframe
allproducts <- tbl(con, "raw_comext_product") %>% collect()
RMySQL::dbDisconnect(con)

# Keep wood products only
wp <- allproducts %>% 
    filter(grepl("^44|^94", productcode))

# For information regexp filtering is also possible with a SQL statement, 
# see for example 
# https://stackoverflow.com/questions/15687136/logical-and-operator-in-mysql-regexp
# and MySQL regexp documentation
# https://dev.mysql.com/doc/refman/5.5/en/regexp.html

# Why are dates read as character vectors?

```

## Are recent product codes unique?
```{r search4uniquecodes}
# A data frame to view in the data explorer
wpdates <- wp %>% 
    group_by(productcode) %>% 
    summarise(maxdatestart = max(datestart),
              datestart = paste(datestart, collapse=", "), 
              dateend = paste(dateend, collapse = ", "),
              # keep only distinct product description
              productdescription = paste(unique(productdescription), collapse = ", "),
              n = n()) %>% 
    arrange(desc(n))

# Wood products repeated
# Keep only the most recent datestart, which still appears more than once
wprep <- wp %>% 
    group_by(productcode) %>% 
    filter(datestart == max(datestart)) %>% 
    summarise(datestart = paste(datestart, collapse=", "), 
              dateend = paste(dateend, collapse = ", "),
              # keep only distinct product description
              productdescription = paste(unique(productdescription), collapse = ", "),
              n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>1) 
wprep %>% kable()

# It seems these lines contain identical information
# In other words, distinct rows for all columns
nrow(unique(wprep)) 
# should be equal to distinct product codes
length(unique(wprep$productcode))
# This can be tested with 
stopifnot(identical(nrow(unique(wprep)), length(unique(wprep$productcode))))    
```

 
## Are datestart2 and dateend2 allways identicall to datestart and dateend?
```{r}
summary(allproducts$datestart == allproducts$datestart2)
summary(allproducts$dateend == allproducts$dateend2)
diffdates <- allproducts %>% 
    filter(datestart != datestart2 |
           dateend != dateend2)
```
No there are 8 rows in which this is not the case.


# cleancodes function debugging
```{r eval=FALSE}
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "test")
inputfields <- RMySQL::dbListFields(con,"raw_comext_product")
outputfields <- RMySQL::dbListFields(con,"val_comext_product")
# validated fields should exist in the raw table
stopifnot(outputfields %in% inputfields)

# clean products:
cleancode(con, "raw_comext_product", "val_comext_product", productcode)
# inside that function, dtf has 21833 rows, this is the number of most recent codes
# returns the error
# Error: identical(nrow(unique(dtf)), nrow(distinct(dtf, !(!codevariable)))) is not TRUE

# Load all products in a dataframe
allproducts <- tbl(con, "raw_comext_product") %>% collect()
RMySQL::dbDisconnect(con)


# Select output fields
# allproducts %>% select(outputfields)
# allproducts[outputfields]

dtf <- allproducts %>% 
    group_by(productcode) %>%
    filter(datestart == max(datestart))
stopifnot(identical(nrow(unique(dtf)),
                    nrow(distinct(dtf, productcode))))
# difference
nrow(unique(dtf)) - nrow(distinct(dtf, productcode))

# What are those duplicated rows?
# group by productcode
dtf_c <- dtf %>%  
    group_by(productcode) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_c_u <- unique(dtf_c)
length(unique(dtf_c_u$productcode))

# group by productcode and productdescription
dtf_cd <- dtf %>%  
    group_by(productcode, productdescription) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_cd_u <- unique(dtf_cd)
length(unique(dtf_cd_u$productcode))

# group by productcode, productdescription, datestart and dateend
dtf_cdse <- dtf %>%  
    group_by(productcode, productdescription, datestart, dateend) %>% 
    mutate(n = n()) %>% 
    arrange(desc(n)) %>% 
    filter(n>2)
dtf_cdse_u <- unique(dtf_cdse)
length(unique(dtf_cdse_u$productcode))


# It seems the descriptions are different:
dtf_c_u$productdescription[1:5]

# Looking at the source file, this seems to be due to the fact that 
# productcodes do not contain only numbers, but can also contain characters

```


# cleanallcodes function
```{r}
# See steps above to recreate the database if needed
con <- RMySQL::dbConnect(RMySQL::MySQL(), dbname = "tradeflows")

cleancode(con, "raw_comext_product", "val_comext_product", productcode)

RMySQL::dbDisconnect(con)

```

# Conclusions
cleancodes should first create the database structure.
The cleancode function should check which columns are present in the validated
table and select only these ones. 

